\chapter{Project Results}
\label{chapter:project_results}
In the following chapter, the author will analyse the results obtained from the hardware and software developed in this thesis project. The author's first objective was running the "Hello World!" firmware with the \textit{VexRiscv} CPU. Secondly, he tested the implementation of the interrupt routine software with the developed CLINT hardware. Finally, the candidate successfully executed the minimal Linux OS in real hardware using the developed System on a chip.

All the results obtained in this thesis which communicate with the FPGA board or the SOC testbench, are executing the developed \textit{Console} program. The hardware components comprising the SOC differ in each section of this chapter. The author customises the SOC hardware depending on the software needs. Along this chapter, the developed SOC will be referenced as the \textit{IOb-SoC-Linux}.

\section{Boot and use the Linux Operating System}
\label{section:boot_linux}
The objective of this thesis project was to run an Operating System in the \textit{IOb-SoC-Linux}. The \textit{IOb-SoC-Linux} used in this section adds the PLIC hardware and substitutes the \textit{iob-UART} for the \textit{iob-UART16550}. The software that comprises the complete OS is the \textit{OpenSBI} bootloader, the device tree blob, the Linux kernel and the root file system.

Table \ref{tab:time_os} presents how much time it takes to build the complete OS with the command \lstinline[language=sh]{make build-OS}. The "real" time is the time that passes since the user executes the command until it finishes. The "user" time is the time the CPU takes while executing operations in the user space. The "user" time is bigger than the "real" time because it counts the time passed in each CPU core. Part of the compilation of the RootFS and the kernel is done in parallel using two cores.

\begin{table}[!ht]
    \centering
    \begin{tabular}{ll}
    real & 4m29,570s \\
    user & 8m12,039s \\
    sys  & 0m56,887s
    \end{tabular}
    \caption{Time it takes to build the OS.}
    \label{tab:time_os}
\end{table}

The OS size is to big to run in the FPGA internal memory. The \textit{OpenSBI} bootloader is 90896 Bytes. The device tree blob is 1669 Bytes. The Linux kernel is 4426152 Bytes. Lastly the root file system is 1142733 Bytes. The memory has to have at least 8 MB ($2^23$) to store all this software. However, the Linux kernel needs a bigger memory where it can store virtual memory pages and execute the different application processes. The device tree source describes the system had 512 MB of available memory. Consequently, the author had to implement the \textit{IOb-SoC-Linux} on the FPGA with access to the external memory. The internal memory could never be as big as 512 MB.

In figure \ref{fig:bootloader_sim} the reader can see the start of the OS simulation with \textit{Verilator}.

\begin{figure}[!ht]
    \centering
    \begin{subfigure}[b]{0.49\textwidth}
        \centering
        \includegraphics[width=\textwidth]{start_bootloader_sim.png}
        \caption{\textit{iob-UART16550} and \textit{iob-PLIC} properties.}
        \label{fig:start_bootloader_sim}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.49\textwidth}
        \centering
        \includegraphics[width=\textwidth]{end_bootloader_sim.png}
        \caption{\textit{IOb-SoC} bootloader and \textit{OpenSBI} firmware.}
        \label{fig:end_bootloader_sim}
    \end{subfigure}
    \caption{Start of the OS simulation with \textit{Verilator}.}
    \label{fig:bootloader_sim}
\end{figure}

Figure \ref{fig:start_bootloader_sim} shows the initialization of the \textit{Console} program. Furthermore, it shows the instantiation of the \textit{iob-UART16550} and the \textit{iob-PLIC}. The \textit{iob-UART16550} and the PLIC core have an initial block that prints their properties. The synthesis tools do not synthesise the initial block to real hardware, but the simulator executes it. Figure \ref{fig:end_bootloader_sim} shows the \textit{iob-bootloader} and the start of the \textit{OpenSBI} bootloader. The \textit{iob-bootloader} in figure \ref{fig:end_bootloader_sim} does not transfer the software to the memory because the author executed the simulation considering that the software was already in the memory.

Figure \ref{fig:start_linux_sim} shows the end of the \textit{OpenSBI} bootloader and the start of the Linux kernel. The first line printed by the Linux kernel indicates the author built the kernel executing, the kernel version and which toolchain he used to compile it.

\begin{figure}[!ht]
    \centering
    \centering
    \includegraphics[width=0.9\textwidth]{start_Linux_sim.png}
    \caption{Start of the Linux kernel boot with \textit{Verilator}.}
    \label{fig:start_linux_sim}
\end{figure}

While figure \ref{fig:start_linux_sim} shows the start of the Linux kernel, figure \ref{fig:end_linux_verilator} shows the end of the Linux kernel booting process and the execution of the "init" script. The "init" script , as seen in subsection \ref{subection:linux_rootfs}, is the first program the OS executes after the Linux kernel mounts the RootFS and finishes booting. There exist multiple messages printed to the terminal between the output shown in figure \ref{fig:start_linux_sim} and in \ref{fig:end_linux_verilator}. Those messages show the progress while the Linux kernel boots. The Linux kernel boot process's last message is \lstinline{Run /init as init process}. After that message the SOC executes the "init" program.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.9\textwidth]{end_Linux_sim.png}
    \caption{End of Linux kernel boot with \textit{Verilator}.}
    \label{fig:end_linux_verilator}
\end{figure}

The warning \lstinline{/bin/sh: can't access tty; job control turned off} that appears at the end of the Linux boot in figure \ref{fig:end_linux_verilator} means the shell program is not writing to a \textit{tty}, but a socket. Advanced commands such as Ctrl+Z and Ctrl+C are unavailable when writing to a socket. Furthermore, sh will not support background processes (command \&) and the associated bg/fg/disown/jobs commands. However, processes forking themselves and closing their inputs will still work. This way, the system is protected from a race condition that could occur if both the shell and the background process were waiting for user input. This problem happens because the author developed the RootFS to be lightweight for embedded systems. Consequently, it does not implement some Linux files and programs that would enable such features. The "init" script could call the shell program could with \lstinline[language=sh]{sh +m}.

Figure \ref{fig:linux_fpga} shows the developed minimal OS running on an FPGA. The reader can see that the author has suppressed the shell warning. The initial part of the figure shows the final stage of the Linux kernel booting. After booting, the author tested the \lstinline[language=sh]{ls /} command that showed the files and directories in the systems' root. Lastly the author executed the \lstinline[language=sh]{cat init} command for the OS to print the contents of the "init" script to the terminal. The difference between the "init" script printed and the one presented in listing \ref{lst:rootfs_init} is that "IObundle" is printed as a design with ASCII characters and the shell program is called with the "+m" argument.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.9\textwidth]{linux_fpga.png}
    \caption{Linux kernel boot in the FPGA.}
    \label{fig:linux_fpga}
\end{figure}

The time the Linux kernel takes to boot in real hardware, figure \ref{fig:linux_fpga}, is almost double what it takes to boot in simulation, figure \ref{fig:linux_fpga}. The time to boot is almost double because the memory module used in the simulation does not have any latency. When the L2 cache fetches data from memory in real hardware, it must wait before receiving the data burst. Using the \textit{CYCLONE V} FPGA board the Linux kernel takes 7.01 seconds to boot. The author expected the boot to take longer since the system clock frequency used with the \textit{CYCLONE V} is 50 MHz. The Kintex Ultrascale was able to run with a frequency of 100 MHz. The \textit{OpenSBI} bootloader and the device tree blob had to be recompiled with the system frequency defined to 50 MHz to run in the \textit{CYCLONE V}.

Table \ref{tab:fpga_linux} show the resources used by the \textit{IOb-SoC-Linux} in the different FPGAs.

\begin{table}[!ht]
    \begin{subtable}[h]{0.45\textwidth}
        \centering
        \begin{tabular}{l|l|l|}
            \cline{2-3}
                                              & Resources & FPGA usage \% \\ \hline
            \multicolumn{1}{|l|}{ALM}         & 11,227    & 10                       \\ \hline
            \multicolumn{1}{|l|}{DSP}         & 8         & 3                        \\ \hline
            \multicolumn{1}{|l|}{FF}          & 13725     & 2                        \\ \hline
            \multicolumn{1}{|l|}{BRAM blocks} & 234       & 19                       \\ \hline
            \multicolumn{1}{|l|}{BRAM bits}   & 755,424   & 9                        \\ \hline
        \end{tabular}
       \caption{Cyclone V GT}
       \label{tab:cyclone_linux}
    \end{subtable}
    \hfill
    \begin{subtable}[h]{0.45\textwidth}
        \centering
        \begin{tabular}{l|l|l|}
            \cline{2-3}
                                            & Resources & FPGA usage \% \\ \hline
            \multicolumn{1}{|l|}{LUTs}      & 23126     & 9.54                     \\ \hline
            \multicolumn{1}{|l|}{Registers} & 24505     & 5.05                     \\ \hline
            \multicolumn{1}{|l|}{DSPs}      & 10        & 0.52                     \\ \hline
            \multicolumn{1}{|l|}{BRAM}      & 39.5      & 6.58                     \\ \hline
        \end{tabular}
        \caption{Kintex Ultrascale}
        \label{tab:kintex_linux}
     \end{subtable}
     \caption{FPGA results for interrupt routine program.}
     \label{tab:fpga_linux}
\end{table}

The tables in \ref{tab:fpga_linux} show that the resources utilization from the \textit{IOb-SoC-Linux} is not much bigger than the \textit{IOb-SoC}. The FPGA still has enough resources to implement hardware accelerators.
