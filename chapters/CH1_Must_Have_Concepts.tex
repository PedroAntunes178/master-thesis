\chapter{Must Have Concepts}
\label{chapter:must_have_concepts}
During this chapter, the author will discuss topics that help understand the technological developments along this thesis project. The developments will involve both hardware and software components. As such, there are hardware and software concepts that are important to have before discussing the following chapters.

The candidate will develop a \acrshort{soc} in this project. However, he will not create it from scratch. The candidate will use the \textit{IOb-SoC} as a starting point. Consequently, it is important to understand how the \textit{IOb-SoC} works beforehand. It is also important to study the \textit{RISC-V} \acrfull{isa}. Since the hardware developed in this project will be compatible with the \textit{RISC-V} \acrshort{isa}. Furthermore, the software developed will be cross-compiled with the \textit{RISC-V} toolchain. An important part when developing a system is its testing and simulation before implementation. Therefore, the author will review the available methods for simulating the developed components. Lastly, an important concept for this project is the boot flow of an \acrfull{os} on a \textit{RISC-V} platform.

\section{The \textit{IOb-SoC} platform}
\label{section:the_iob_soc_template}
The \textit{IOb-SoC}~\cite{iob_soc_repo} is a System-on-Chip (SoC) template that eases the creation of a new SoC. The \textit{IOb-SoC} provides a base Verilog hardware design equipped with an open-source \textit{RISC-V} processor, an internal SRAM memory subsystem, a UART, and an optional interface to external memory. If the external memory interface is selected, the \textit{IOb-SoC} will include an instruction L1 cache, a data L1 cache and a shared L2 cache. The L2 cache communicates with a third-party memory controller IP (typically a DDR controller) using an AXI4 master bus. Users can add IP cores and software to build their own SoCs quickly. This way, hardware accelerators can be easily created and tested with the developed firmware.

In figure \ref{fig:bd_original} it is represented a sketch of the \acrshort{soc} design. This design is valid at the start of this project. During the hardware developed chapter \ref{chapter:hardware_developed} some alterations were made to the \textit{IOb-SoC} original template.

\begin{figure}[!h]
    \centering
    \includegraphics[width=0.7\linewidth]{bd_original.pdf}
    \caption{\textit{IOb-SoC} sketch.}
    \label{fig:bd_original}
\end{figure}

Building a new processor-based system from scratch can be difficult. The \textit{IObundle} developers created the \textit{IOb-SoC} to facilitate this process. This work develops a variant of the existing \textit{IOb-SoC} capable of running a Linux Operating System. \textit{IOb-SoC} currently supports two FPGA board models: the Xilinx Kintex UltraScale KU040 Development Board and the Cyclone V GT FPGA Development Kit.

\subsection{\textit{IOb-SoC} \textit{Makefiles}}
\textit{Makefiles} are essential because they allow automating processes. This way, instead of executing multiple lines to achieve a goal, the user can run a single command. That command will execute a \textit{Makefile} script that runs the multiple processes needed to achieve a specific goal without specifying them. For example, to run a simulation, a developer using this project \acrshort{soc} would only have to write in the terminal the commands in listing~\ref{lst:run_simulation}.

\begin{lstlisting}[language=make, caption={Run a simulation.}, label=lst:run_simulation]
    make sim-clean
    make sim-run
\end{lstlisting}

The first command in listing~\ref{lst:run_simulation} cleans all the files related to a previous simulation execution. Then the second command runs a new simulation. This simulation will use the default configurations in the \enquote{config.mk} file. A \textit{Makefile} target follows each of the \enquote{make} commands. A target is a section of the \textit{Makefile} that may or may not depend on other targets and executes a sequence of commands. In the example~\ref{lst:run_simulation} there are two targets, \enquote{sim-clean} and \enquote{sim-run}.

The main \textit{Makefile} in \textit{IOb-SoC} is located at the \textit{IOb-SoC} root directory. The main \textit{Makefile} contains targets that call other \textit{Makefiles} and sets the values for the default frequency, baud rate, \acrshort{fpga} board used and simulator used. The \textit{Makefiles} the main one can call are at the \textit{IOb-SoC} \acrshort{fpga} boards, simulators, firmware, \enquote{PC} emulation or documentation directory. Each directory in \textit{IOb-SoC} contains a \enquote{*.mk} file which holds \enquote{make} variables and targets that complement the \textit{Makefiles}. The \textit{IOb-SoC} \textit{Makefiles} can include only the \enquote{*.mk} they need.

When executing the command \lstinline[language=bash]{make sim-run} the computer will run the \enquote{run} target of the \textit{Makefile} in the default simulator directory. The simulator \textit{Makefile} will include the \enquote{simulator.mk}, \enquote{hardware.mk} and \enquote{config.mk} files. The \enquote{simulator.mk} file is common to all simulators. Both \acrshort{fpga}s and simulators \textit{Makefiles} include the \enquote{hardware.mk} file. The \enquote{hardware.mk} file includes all the hardware modules that the \acrshort{soc} uses. Lastly, the \enquote{config.mk} is located at the \textit{IOb-SoC} root directory and all \textit{Makefiles} use it. The \enquote{config.mk} defines the \enquote{make} variables that are important for hardware and software, for example which peripherals the \acrshort{soc} contains.

\subsection{\textit{IOb-SoC} peripherals}
Developers add the \textit{IOb-SoC} peripherals under the submodules directory in the \textit{IOb-SoC} folder. Inside the submodules directory, there exists a folder for each peripheral. Furthermore, the \acrshort{cpu}, the \enquote{iob\_cache} module, the \enquote{iob\_mem} hardware, the \enquote{iob\_axi} interface and the \textit{iob-LIB} repository can also be found in the submodules directory. The \textit{IObundle} engineers developed the \textit{iob-LIB} submodule for it to contain small generic hardware modules and software script used in \textit{IOb-SoC}.

All the submodules may contain hardware and software components. For each hardware peripheral, the \textit{IOb-SoC} engineers recommend developing a set of bare-metal firmware functions that allow using the peripheral with the \acrshort{soc} without an \acrshort{os}. Since the \textit{IOb-SoC} platform also allows emulating the developed firmware in the user's personal computer, the peripherals should have software functions that emulate its firmware drivers.

The peripheral should have the following \enquote{*.mk} files to integrate it into \textit{IOb-SoC}:
\begin{itemize}
    \item the \enquote{PERIPHERAL\_REPO/hardware/hardware.mk} so the user can add the peripheral hardware modules to the \acrshort{soc}.
    \item the \enquote{PERIPHERAL\_REPO/software/embedded/embedded.mk} allows the user to use the peripheral firmware drivers.
    \item the \enquote{PERIPHERAL\_REPO/software/pc-emul/pc-emul.mk} permits emulating the peripheral behaviour in the user's computer.
\end{itemize}
The developer has to include the \enquote{PERIPHERAL\_REPO/hardware/hardware.mk} file in the \textit{IOb-SoC} \enquote{hardware.mk} file. He can include it by adding \lstinline[language=make]{include $(PERIPHERAL_DIR)/hardware/hardware.mk} to the \textit{IOb-SoC} \enquote{hardware.mk}. In the firmware \textit{Makefile} the develops has to include the peripherals \enquote{embedded.mk} file by adding \lstinline[language=make]{include $(PERIPHERAL_DIR)/software/embedded/embedded.mk} to use the peripheral drivers. Lastly in the \enquote{pc-emul} \textit{Makefile} he has to add \lstinline[language=make]{include $(PERIPHERAL_DIR)/software/pc-emul/pc-emul.mk} to allow the software to emulate the peripheral.

In the \enquote{config.mk} file, located in the \textit{IOb-SoC} repository root, the developer needs to add the \enquote{PERIPHERAL\_REPO} to the \enquote{PERIPHERALS} \enquote{make} variable and create a variable that indicates the peripheral directory. The user should define the variable that indicates the peripheral directory similarly to \lstinline[language=make]{PERIPHERAL_DIR=$(ROOT_DIR)/submodules/PERIPHERAL_REPO}.

The peripheral also needs the following files to be automatically instantiated in the \acrshort{soc} hardware: \enquote{inst\_tb.vh}, \enquote{inst.vh} and \enquote{pio.vh}. The \textit{Makefiles} use the \enquote{inst\_tb.vh} file to add the needed Verilog to the testbench core for the system to simulate. It uses the \enquote{inst.vh} to instantiate the peripheral hardware module in the \textit{IOb-SoC} core. Finally, the \enquote{pio.vh} file contains input and output signals that the \textit{Makefiles} must add to the system core hardware. Those files should be in the \enquote{PERIPHERAL\_REPO/hardware/include} directory. Listing \ref{lst:inst_file} presents an example of the \enquote{inst.vh} contents.

\begin{lstlisting}[language=Verilog, caption={Example of the \enquote{inst.vh} file.}, label=lst:inst_file]
//
// TIMER
//
iob_timer timer
  (
   .clk      (clk),
   .rst      (reset),

   //cpu interface
   .valid(slaves_req[`valid(`TIMER)]),
   .address(slaves_req[`address(`TIMER,`TIMER_ADDR_W+2)-2]),
   .wdata(slaves_req[`wdata(`TIMER)]),
   .wstrb(slaves_req[`wstrb(`TIMER)]),
   .rdata(slaves_resp[`rdata(`TIMER)]),
   .ready(slaves_resp[`ready(`TIMER)])
   );
\end{lstlisting}

\subsection{Internal Buses}
The \textit{IOb-SoC} is designed in a way there exists one master hardware component and multiple slave hardware components. To Interconnect the hardware components \textit{IOb-SoC} defines two type of buses, the request bus and the response bus. In \textit{IOb-SoC} the master component is the \acrshort{cpu}. The \acrshort{cpu} send requests to the internal or external memory and the peripherals through the request buses. After making a request the \acrshort{cpu} will receive the response through the respective response bus. The \acrshort{cpu} instantiated in the \textit{IOb-SoC} core has the \enquote{cpu\_i\_req}, \enquote{cpu\_d\_req}, \enquote{cpu\_i\_resp} and \enquote{cpu\_d\_resp} signals. The \enquote{cpu\_i\_req} signal serves to fetch instructions from memory and the \enquote{cpu\_i\_resp} will contain the instruction fetched after a few clock cycles. The \acrshort{cpu} uses the \enquote{cpu\_d\_req} to make data requests to either the memory or a \acrshort{soc} peripheral.

The request bus is composed by a valid bit, an address signal, a data signal and a strobe signal. The hardware sets the valid bit to high when it wants to execute a request and the other signal are already set. The address signal indicates the memory address request is meant for. Figure \ref{fig:req_bus} shows how the signals in the request bus are distributed. Furthermore, figure \ref{fig:req_bus} also represents the bits equivalent to each signal when the address width and data width are 32 bits. The address and data width in \textit{IOb-SoC} are 32 bit by default.

\begin{figure}[!h]
    \centering
    \includegraphics[width=\linewidth]{req_bus.pdf}
    \caption{Request bus with address and data width equal to 32 bits.}
    \label{fig:req_bus}
\end{figure}

The response bus is comprised of a ready bit and a data signal. The hardware sets the ready signal to high when the component who made the request can receive the response. The data signal is the response data to the request made. For example, if the cpu wants to read the value in a register at address \enquote{x} the data in the response bus will be the data on register \enquote{x}. Figure \ref{fig:resp_bus} shows how the request signal is composed when the address and data width are 32 bits.

\begin{figure}[!h]
    \centering
    \includegraphics[width=\linewidth]{resp_bus.pdf}
    \caption{Response bus with address and data width equal to 32 bits.}
    \label{fig:resp_bus}
\end{figure}

In the \textit{iob-LIB} submodule exists a file, called \enquote{iob\_intercon.vh}, that defines a set of macros that can be used in \textit{Verilog}. Those macros can be used to access the specific bits in the \textit{IOb-SoC} buses. Table \ref{tab:bus_defines} shows the defined macros, how the pre-compiler calculates their value and their values when the address and data width are 32 bit.

\begin{table}[!ht]
    \centering
    \begin{tabular}{|l|l|l|l|}
    \hline
    \textbf{Name} & \textbf{Defined expression}          & \textbf{Description}                  & \textbf{\begin{tabular}[c]{@{}l@{}}Value with:\\   ADDR\_W=32\\   DATA\_W=32\end{tabular}} \\ \hline
    READY\_W      & 1                                    & Response ready width                  & 1                                                                                          \\ \hline
    VALID\_W      & 1                                    & Request valid width                   & 1                                                                                          \\ \hline
    WSTRB\_W      & DATA\_W/8                            & Request data width                    & 4                                                                                          \\ \hline
    WRITE\_W      & DATA\_W+DATA\_W/8                    & Most significant bit of request data  & 36                                                                                         \\ \hline
    READ\_W       & DATA\_W+READY\_W                     & Most significant bit of response data & 33                                                                                         \\ \hline
    WDATA\_P      & DATA\_W/8                            & Less significant bit of request data  & 4                                                                                          \\ \hline
    ADDR\_P       & DATA\_W+DATA\_W/8                    & Less significant bit of request data  & 36                                                                                         \\ \hline
    VALID\_P      & ADDR\_W+DATA\_W+DATA\_W/8            & Request bus valid bit position        & 67                                                                                         \\ \hline
    REQ\_W        & VALID\_W+ADDR\_W+WRITE\_W            & Request bus width                     & 69                                                                                         \\ \hline
    RESP\_W       & DATA\_W+READY\_W                     & Response bus width                    & 33                                                                                         \\ \hline
    req(I)        & I*REQ\_W +: REQ\_W                   & Request bus bits boundary             & I*69 +: 69                                                                                 \\ \hline
    resp(I)       & I*RESP\_W +: RESP\_W                 & Response bus bits boundary            & I*33 +: 33                                                                                 \\ \hline
    valid(I)      & I*REQ\_W+VALID\_P                    & Request valid bit position            & I*69+1                                                                                     \\ \hline
    address(I,W)  & I*REQ\_W+ADDR\_P+W-1 -: W            & Request address bits boundary         & I*69+W+35 -: W                                                                             \\ \hline
    wdata(I)      & I*REQ\_W+WDATA\_P +: DATA\_W         & Request data bits boundary            & I*69+4 +: 32                                                                               \\ \hline
    wstrb(I)      & I*REQ\_W +: WSTRB\_W                 & Request strb bits boundary            & I*69 +: 4                                                                                  \\ \hline
    write(I)      & I*REQ\_W +: WRITE\_W                 & Request write bits boundary           & I*69 +: 36                                                                                 \\ \hline
    rdata(I)      & I*RESP\_W+READY\_W +: DATA\_W        & Response data bits boundary           & I*33+1 +: 32                                                                               \\ \hline
    ready(I)      & I*RESP\_W                            & Response ready bit position           & I*33                                                                                       \\ \hline
    \end{tabular}
    \caption{Bus interconnect macros.}
    \label{tab:bus_defines}
\end{table}

Understanding the interconnect macros is essential when developing the interface with peripherals and hardware components for the \textit{IOb-SoC}. Some macros depend on an \enquote{I} value given to them when using the macro. That \enquote{I} value is used to distinguish which request or response signal the developers wants to access when there is a bus (i.e. wire) with multiple requests or responses bundled up together. In the \enquote{address(I,W)} macro, the \enquote{W} value corresponds to the number of bits of the address in the request signal the developer wants to select.

\subsection{\textit{iob-split} and \textit{iob-merge}}
The \textit{iob-split} and the \textit{iob-merge} hardware modules can both be found in the \textit{iob-LIB} submodule hardware directory. The \textit{IOb-SoC} uses the \textit{iob-split} in the systems core and in the internal memory hardware modules. The \textit{iob-split} in \textit{IOb-SoC} serves to separate one request and one response bus into multiple buses and only enable the needed one. For example, there are multiple peripheral and each peripheral has an input request bus and an output response bus. However there is only one \enquote{cpu\_d\_req}. The \textit{iob-split} only sends the \enquote{cpu\_d\_req} signal to the selected peripheral and sets the other peripherals request bus to zeros. The \textit{IOb-SoC} instantiates the \textit{iob-merge} in the external and internal memory hardware modules. The \textit{iob-merge} unifies multiple request and response buses into one. For example the \acrshort{cpu} can execute both instructions and data request to the memory. Nevertheless, the memory can only process one request at a time. The \textit{iob-merge} merges the \enquote{cpu\_i\_req} and the \enquote{cpu\_i\_req} and sends to the memory the request with higher priority or the one that was first set has valid.

The \textbf{\textit{iob-split}} is simply a configurable \acrfull{demux}. Meaning that when the \textit{iob-split} hardware module is instantiated the developer can configure it. The developer is able to change the size of the \acrlong{demux} and the selection bits, through N\_SLAVES and P\_SLAVES respectively. N\_SLAVES corresponds to the number of slaves, witch can also be seen as the number of the \acrshort{demux} outputs. P\_SLAVES indicates the slave select word \acrfull{msb} position, in other words it is the position of the \acrshort{msb} of the \acrlong{demux} selection bits. The number of the selection bits is given by equation \ref{eq:number_bits}.

\begin{equation}
    \label{eq:number_bits}
    Nb = log_2(N\_SLAVES)+(log_2(N\_SLAVES)==0)
\end{equation}

The \textbf{\textit{iob-merge}} works similar to the \textit{iob-split} but instead of being a \acrshort{demux} it is a configurable \acrfull{mux}. Meaning that instead of having multiple outputs and one input it has multiple inputs and one output. The number of inputs is indicated by N\_SLAVES and the selection bits are chosen by P\_SLAVES.

\subsection{Bootloader}
The \textit{IObundle} engineers developed a bootloader for \textit{IOb-SoC} that is the first firmware to run on the \acrlong{soc}. The bootloader firmware is always saved in the \acrshort{soc} internal memory in a boot control hardware unit. The boot control hardware unit defines the boot signal. The boot signal is one bit that can be set to high ('1') or low ('0') and indicates whether the \acrshort{soc} should execute the bootloader or other firmware. Moreover, the boot control unit sends a reset signal to the \acrshort{cpu} when the bootloader ends, before starting the users firmware.

Figure \ref{fig:boot_flow} represents a flow chart of the bootloader firmware behaviour. The bootloader starts by initializing the \acrshort{uart} hardware which the \acrshort{soc} uses to communicate with the users computer. Then it will send an \acrfull{enq} if it still has not sent one. The \acrshort{enq} byte has the value of 0x05 in ascii and is sent to the users computer to indicate that the \textit{IOb-SoC} is waiting for the users computer. The bootloader is going to make sure the \acrshort{uart} is sending the \acrshort{enq} byte while the users computer does not send a response. After receiving a response byte the bootloader firmware checks if the received byte is an \acrfull{frx}. The \acrshort{frx} Byte has the value 0x07. If the bootloader receives a \acrshort{frx} it means the bootloader has to transfer the firmware that is to run after it.

\begin{figure}[!h]
    \centering
    \includegraphics[width=\linewidth]{boot_flow.pdf}
    \caption{Bootloader firmware flow chart.}
    \label{fig:boot_flow}
\end{figure}

When transferring the firmware the bootloader receives the firmware binary data through the \acrshort{uart} and copies it to the \acrshort{soc} memory. The bootloader can copy the firmware to either the internal or external memory depending on where the user defined the firmware would run from. After copying the firmware to the \textit{IOb-SoC} the bootloader will send the data saved in the memory back to the users computer. The users computer can then check if the firmware was successfully transferred by comparing the original firmware binary with the received copy. Before exiting the bootloader will clean the cache so that the next firmware to run does not fetch data previously in cache. Finally, when exiting the bootloader asks the boot control unit to set the boot signal to low and reset the \acrshort{cpu}.

\section{\textit{RISC-V}}
\label{section:riscv}
RISC-V is a free, open-source RISC Instruction Set Architecture (ISA). An ISA is the bridge that connects software and hardware. RISC is one possible classification of the computer ISA's; it means reduced instruction set computer, and the essence of this approach is the simplicity of the instructions computed by the CPU. Unlike a Complex Instruction Set Computer (CISC) ISA, the CPU might have to execute a more significant number of instructions with a RISC ISA to obtain the same result. Since the instructions are simple, more instructions need to be run to complete a given task. However, the architecture is lighter and can run at a higher frequency, compensating for executing more instructions.

The RISC-V was initially designed at the University of California, Berkeley. Furthermore, it is called RISC-V because it is the fifth RISC instruction set architecture to come out of that university. It was created to support computer architecture research and education. Although now RISC-V is used on commercial projects as well. A key advantage of RISC-V is its flexibility. It can be used from high-performance computers to deeply embedded systems with no MMU. There exists a 32, 64 and 128-bit version of RISC-V. In this report, the 32 and 64-bit versions will be discussed. On the work developed during the thesis preferentially, the 32-bit version will be used. If an instruction is not on the standard RISC-V, it can be created as an ISA extension, which provides excellent flexibility.

There are two main parts of the RISC-V ISA. There are the \textit{unprivileged} instructions that correspond to the base ISA~\cite{riscv_unpriviledge}, which is composed of only 32-bit instructions and some unprivileged extensions. {\it Unprivileged instructions} are the instructions that can be used on all privilege modes in all privilege architecture. Moreover, there exists the privilege instructions~\cite{riscv_priviledge} that implements support for the three different privilege levels. Machine mode is the most trusted privilege level, and typically what runs in this mode has low-level access to the machine implementation. The other two modes are the User mode, where most common applications run, and the OS's Supervisor mode. Each privileged mode has its extensions to the ISA.

To install the RISC-V tool chain~\cite{riscv:toolchain} the user can clone their repository and make the necessary cross-compilers. To work with the IOb-SoC, the user will have to install the Newlib cross-compiler. For this work and the development of the thesis, the Linux cross-compiler had to be installed.

Talk about the 32 registers in the register file

The instruction each ISA extension contains...

\acrfull{csr} needed to run a full feature OS... (core\_id, misa, mcause, ...)

\subsection{CLINT Specification}
The \textit{RISC-V} \textbf{CLINT} is described ...
Platform must support an ACLINT MTIME counter resolution of 100ns or less (corresponding to a clock tick frequency of at least 10 MHz).

\subsection{PLIC Specification}
The \textit{RISC-V} \textbf{PLIC} was first described in the privilege instructions documentation, but since version 1.10 it was moved to its own document.

\subsection{UART/Serial Console}
\label{section:serial_console}
In the \textit{RISC-V} Platform Specification~\cite{riscv_platform_specification} it is defined that every embedded \acrfull{os} is required to have a \acrshort{uart} port implementation that is register-compatible with the industry standard \textit{UART 16550}, which was studied in chapter~\ref{section:uart16550}. The \textit{UART 16550} already exists for a long time, it was released by \textit{National Semiconductor} in 1987, and is present and supported by a large number of software and hardware. The \textit{UART 16550} is often used connected to an RS-232 interface and in this project the development boards used are connected through RS-232 to the computer.

The \textit{UART 16550} registers are...

\section{The Linux Boot Flow on \textit{RISC-V}}
\label{section:linux_boot_flow}
\subsection{Bootloader firmware}
OpenSBI
\subsection{What is a device tree?}

\section{Open Source Verification tools}
\label{section:verification_tools}
Verification tools are ....

https://www.sifive.com/blog/risc-v-qemu-part-1-privileged-isa-hifive1-virtio

\subsection{Hardware logic simulators}
For testing purposes, it is important to have a good hardware simulation environment. For that, we take advantage of already existing and well-developed tools. There exist a number of simulation tools, most of them are proprietary, as for example \textit{xcelium} from \textit{Candence}. Its utilization can increase the cost of a project significantly. In this Thesis we will make an effort of using open-source, free to use, verification tools. In specific, we will take advantage of \textit{Icarus Verilog} and \textit{Verilator}. Although both tools are for verification, they serve different purposes, due to their characteristics.

\begin{itemize}
    \item \textbf{\textit{Icarus Verilog}} is a Logic Simulator that uses verilog or system-verilog testbenchs to test the UUT (Unit Under Test). Unfortunately, its support for system-verilog is limited and some designs might not run in this simulator. \textit{Icarus Verilog} is also known as \textit{IVerilog}.
    
    After compiling the hardware design, \textit{IVerilog} outputs a file which can be run line by line to simulate designed logic.
    
    \item \textbf{\textit{Verilator}} transforms the \textit{Verilog} \acrshort{hdl} designs into a \textit{C++} program that can be executed after being compiled. Using \textit{C++} to create a testbench allows to execute the converted hardware program as a normal program. This way simulating the hardware initially described in \textit{Verilog}. While also allowing to easily make use of system calls. The testbench needed to run with Verilator is similar to the testbench in \textit{Verilog} used with \textit{Icarus}.
\end{itemize}

\textbf{The biggest differences} are: \textit{Verilator} only represents logic signal as 1's or 0's, contrary to \textit{IVerilog} which also represents unknown values as X's; Since \textit{Verilator} ends up being a C++ program it is much faster to run the simulation than with \textit{IVerilog}; On another perspective \textit{Verilator} is slower than \textit{IVerilog} to interpret the hardware logic design.
As such, it is easier to use \textit{IVerilog} to detect errors on the design, but it is better to use \textit{Verilator} for more complexed simulations.

\subsection{Qemu Simulation}
QEMU is an open-source machine emulator and virtualizer, allowing running software and firmware, like operating systems and Linux distributions on many different devices and architecture using a personal computer. It is similar to VMware or VirtualBox. QEMU is a functional emulator; it translates the instructions that were supposed to run on the target architecture to instructions that run on the host CPU. Other types of emulators are Trace-accurate, like Spike, and Cycle-accurate, for example, Verilator. The advantage of using a functional emulator like QEMU is that it is way faster than the other emulation types. A functional emulator runs 100 million to > 1 billion instructions per second, while trace-accurate or cycle-accurate run 10 to 100 thousand instructions per second.

Emulating Linux in \textit{RISC-V} with QEMU is helpful to create and test software for \textit{RISC-V} platforms. QEMU can be used to emulate both 32-bit and 64-bit \textit{RISC-V} CPUs. During this work, an implementation of the Linux kernel will be tested on QEMU running on a \textit{RISC-V} board. The platform that is going to be used is the \textit{virt} board. Virt is a board that does not contain any real hardware but is designed to be used in virtual machines. To define which board the emulation is supposed to run in when calling QEMU, the following argument should be passed: \textit{--machine virt}.
