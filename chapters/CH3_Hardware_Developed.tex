\chapter{Hardware Developed}
\label{chapter:hardware_developed}
During the development of this thesis, there was both hardware and software developed. In this chapter, we are going to go through the hardware developed to build an appropriate \acrfull{soc} capable of running a full-fledged \acrfull{os}.

The \textit{IOb-SoC} was used as a \acrfull{soc} template. \textit{IOb-SoC} has some features that make it ideal to develop this project \acrshort{soc}. Firstly, it is open-source hardware. This means there are no royalties and the source code is publicly available. Secondly, adding new peripherals is very easy and intuitive, as was previously seen in section~\ref{section:the_iob_soc_template}. Thirdly, the \textit{IOb-SoC} implements the interface with an internal (SRAM) and an external (DRAM) memory. When using an external memory the \textit{IOb-SoC} instantiates an \textit{iob-cache} system. Finally, the \textit{IOb-SoC} implements a boot hardware unit that controls the first boot stage (also known as stage zero) that is executed after powering/resetting the system.

The hardware components that needed to be changed from \textit{IOb-SoC} were the \acrfull{cpu} and the \acrfull{uart} peripheral. The \acrshort{cpu} had to be changed because the previous \acrshort{cpu} (\textit{PicoRV32}) is not capable of running a full-feature \acrlong{os}. The \acrshort{uart} had to be swapped since there were no compatible Linux drivers that worked with \textit{iob-UART}. Besides swapping a few components from the chip new hardware had to be added. The additional hardware is the \acrshort{clint} and the \acrshort{plic} both compatible with RISC-V specifications. The \acrshort{clint} was added to implement timer and software interrupts on the \acrshort{soc}. The \acrshort{plic} was added to manage interrupts generated by other peripherals, for example from the \acrshort{uart}. A sketch of the \acrshort{soc} developed can be seen in figure \ref{fig:bd_linux}.

\begin{figure}[!h]
    \centering
    \includegraphics[width=0.7\linewidth]{bd_linux.pdf}
    \caption{Developed \acrshort{soc} sketch.}
    \label{fig:bd_linux}
\end{figure}

Comparing figure \ref{fig:bd_linux} with the original design of \textit{IOb-SoC} (figure \ref{fig:bd_original}) we can see that there were a few additional alterations. In the first place, it can be seen that the L1 Cache was removed. Since every application processor studied had an L1 cache built in, there was no need for the L1 \textit{iob-cache}. Next, a \textit{iob-split} was added to the \textit{IOb-SoC}. Previously, there was a single \textit{iob-split} for the data bus with three slaves (the internal memory, the external memory and the peripheral bus). This meant that there were 2 selection bits, when '00' then the internal memory bus was active, when '01' it was the peripheral bus and when '10' it was the external memory. This caused a problem because when addressing the external memory if its size is bigger than 1GB the selection bits would be '11'. The \acrfull{demux} output selected by '11' is not connected anywhere, so this caused an internal hardware error. The solution was to include two \textit{iob-split} modules each with two slaves. The first would choose between the external memory and either the internal memory or peripheral bus. The second would choose between the internal memory and the peripheral bus. Another advantage of using this method is that now the selection bit's position does not vary depending on if we are using the DDR or not. This makes it easier to use external software that does not use the \textit{iob-soc} Makefiles. Before the peripheral addressing on external software had to be changed every time the developer wanted to test with or without the external memory.

During this project, there was also an improvement on the \textit{IOb-SoC} verification. This led to the creation of a top hardware module for the developed \acrlong{soc}.

\section{Central Processing Unit}
\label{section:cpu}
The \acrshort{cpu} chosen to use in this project was \textit{VexRiscv}. The performance of the CPU is not a significant issue for this project. However, how the core was designed and developed highly influenced the CPU decision. The flexibility of the CPU design, meaning how easily the CPU can be adapted to take advantage of the other components in \textit{IOb-SoC}, is an essential factor. Since the hardware and software developed in this project are open-source, the CPU implemented had to be open-source hardware. Moreover, knowing that the \textit{IOb-SoC} signals are 32-bit wide, ideally, the selected CPU should support RV32IMAC to facilitate its integration with IOb-SoC. From the \acrshort{cpu}s studied in chapter \ref{chapter:existing_embedded_technologies} \textit{VexRiscv} looked like the more indicated.

Generating the \acrshort{rtl} \textit{verilog} file from the \textit{SpinalHDL} hardware description is very simple. After cloning the \textit{VexRiscv} GitHub repository the developer only has to run one command. As can be seen below in listing \ref{lst:rtl_vexriscv}. On the \textit{VexRiscv} repository there exist a couple of demo \acrshort{cpu} configurations. The configurations can be directly used or configured to generate a custom \textit{VexRiscv} core. There even already exists a demo configuration to generate a Linux-compatible core. Although in the developed hardware a custom core was implemented, the Linux demo configuration was used as a starting point. Unfortunately, the Linux Demo design is outdated and the instructions, commented on the hardware configuration file, to run a Linux simulation and test the core does not work.

\begin{lstlisting}[language=make, caption={Generate \textit{verilog} from \textit{SpinalHDL}}, label=lst:rtl_vexriscv]
git clone https://github.com/SpinalHDL/VexRiscv.git && \
  cd VexRiscv && sbt "runMain vexriscv.demo.LinuxGen"
\end{lstlisting}

The \textit{VexRiscv} can be configured by adding and removing plugins. Plugins are hardware components described in \textit{SpinalHDL} that can be reused in different designs by simply adding \enquote{\textcolor{green}{new} \textcolor{red}{Plugin\_Name}(...),} to the plugins list in the top \acrshort{cpu} description file. The existing plugins are described in the \textit{VexRiscv} repository on the \enquote{src/main/scala/vexriscv/plugin} directory. Looking at the available plugins it can be seen that there are two different plugins for the instruction bus and data bus. They are \enquote{IBusSimplePlugin}, \enquote{IBusCachedPlugin}, \enquote{DBusSimplePlugin} and \enquote{DBusCachedPlugin}. The difference is that the \enquote{cached} plugins have the L1 Cache integrated, while the simple plugins do not. An additional different between the data cached and simple plugin it that, although the \enquote{DBusCachedPlugin} fully supports the RISC-V atomic extension, the \enquote{DBusSimplePlugin} supports \acrfull{lr}/\acrfull{sc} but not \acrfull{amo} instructions. The \enquote{DBusSimplePlugin} could also be adapted to enable the full \enquote{A} extension, but since I do not understand how to code in \textit{SpinalHDL} it would be very time-consuming.

The first step on implementing the \textit{VexRiscv} core on the \textit{IOb-SoC} was making sure that it worked on \enquote{bare metal} applications. Meaning it had to be working with the application accessing the silicon chip directly without any intermediary like an \acrfull{os}. This was done using the instruction and data \enquote{simple} plugins. The next step was to run the Linux kernel. To do so the instruction and data \enquote{simple} plugins had to be changed to the \enquote{cached} plugins. The missing support for \acrfull{amo} instructions was noticeable because the software would stop executing and enable an unknown instruction signal. It was possible to identify which instruction was causing the problem through the signal waves created during simulation.

The final \textit{VexRiscv} core configuration file contained the needed plugins to run a minimal \acrfull{os} based on Linux. The plugins present were:
% The file can be found in the project git hub repository under (\url{https://github.com/IObundle/iob-vexriscv/blob/cached_vexriscv/software/vexriscv_core/Linux.scala}).
\begin{itemize}
  \item The \enquote{IBusCachedPlugin} was added. With it, the address of the first instruction the CPU had to fetch was defined by setting the reset value of the \acrfull{pc}. Also, it was specified that the CPU had no branch predictor and that it supported compressed instructions. The decision to not use any branch predictor was because there seemed to be a compatibility problem between the most recent RISC-V toolchain and the branch predictor that are available in the \textit{VexRiscv}. Since performance was not a concern in this project I choose to not use a branch predictor.
  \item The \enquote{DBusCachedPlugin} was added for the reason that it fully supported the atomic instructions.
  \item The \enquote{DecoderSimplePlugin} is used to decode the instructions.
  \item The \enquote{RegFilePlugin} implements the register file. These are the registers inside the CPU.
  \item The \enquote{IntAluPlugin} is used to calculate arithmetic and logic operations.
  \item The \enquote{SrcPlugin} is an auxiliary plugin for the plugins that contain \acrfull{alu}, Branch related hardware and Load/Store hardware logic.
  \item The \enquote{FullBarrelShifterPlugin} implements the shift instructions present in the RISC-V base \acrfull{isa}.
  \item The \enquote{HazardSimplePlugin} is used by the core to determine where it needs to stall.
  \item The \enquote{MulPlugin} allows the core to execute multiplication instructions.
  \item The \enquote{MulDivIterativePlugin} could be used to add multiplication and division support to the core (RISC-V M \acrshort{isa} extension). In this case, it was used to add only division since the multiplication support was added by another plugin.
  \item The \enquote{CsrPlugin} is configured to fully support Linux. This plugins adds the needed \acrfull{csr} to run a full feature \acrshort{os}.
  \item The \enquote{DebugPlugin} was deactivated in the used core. But it could be used to debug the CPU core if there existed a JTAG interface. Currently the \textit{IOb-SoC} does not support it.
  \item The \enquote{BranchPlugin} allows the core to execute and make decisions on the jump instructions. This is part of the base \acrfull{isa}
  \item The \enquote{MmuPlugin} added support for the \acrfull{mmu}. Which is required to run a full feature \acrshort{os}.
  \item The \enquote{FpuPlugin} can add support for both the floats and doubles instruction extensions. In the core used this plugin was deactivated since to run a minimal \acrshort{os} there is little to no advantage of using this extension. Causing the FPU to only be adding unnecessary hardware logic.
  %\item The \enquote{YamlPlugin} offers a service to other plugins to generate a useful Yaml file describing the CPU configuration. % It needs to be there for some reason. I am dunno.
\end{itemize}

After generating the Verilog file that describes a \textit{VexRiscv} core I had to create a wrapper hardware module that adapted the \textit{VexRiscv} core interface to the \textit{IOb-SoC} internal bus.

\subsection{VexRiscv Wrapper}
The Verilog wrapper, witch is called \textit{iob\_VexRiscv}, is instantiated by the \textit{IOb-SoC} top \acrshort{soc} hardware module as the \acrshort{cpu} component and instantiates the \textit{VexRiscv} core Verilog module. The interface between the \textit{IOb-SoC} hardware and the \textit{VexRiscv} core is created by establishing a connection between the inputs and outputs from both sides.

The input signals of \textit{iob\_vexriscv} are the clock signal which is the system clock derivative from the development board where the \acrshort{soc} is implemented; the reset signal which is set to high ('1') when the system reboots and when the stage 0 bootloader finishes; the boot signal that has the value '1' while the stage 0 bootloader is executing, after it finishes the boot signal value drops to '0' at the same time the reset signal is set to high; the instruction bus response signal that is connected to \enquote{cpu\_i\_resp}; the data bus response signal that is connected to \enquote{cpu\_d\_resp}; the timer interrupt and software interrupt signals which are set to '1' or '0' by the \acrshort{clint} unit; the external interrupt signal which is controlled by the \acrshort{plic} unit. The output signals are the instruction bus request signal and the data bus request signal, which connect to the \enquote{cpu\_i\_req} and \enquote{cpu\_d\_req} respectably. The \enquote{cpu\_i\_resp}, \enquote{cpu\_d\_resp}, \enquote{cpu\_i\_req} and \enquote{cpu\_d\_req} signals were reviewed in section \ref{section:the_iob_soc_template}.

The input and output signals of the \textit{VexRiscv} core can be seen in table \ref{tab:vexriscv_core_and_iob_soc}. It can also be seen the signal's width and their equivalent signal in the \textit{IOb-SoC} top hardware.

\begin{table}[!ht]
  \centering
  \resizebox{\textwidth}{!}{%
  \begin{tabular}{|l|l|l|l|l|}
    \hline
    \textbf{Port}                & \textbf{Width} & \textbf{Direction} & \textbf{Description}                                                                                          & \textbf{IOb-SoC Port}           \\ \hline
    dBus\_cmd\_valid             & 1              & output             & \begin{tabular}[c]{@{}l@{}}Indicates that the CPU is ready\\  to make a data request.\end{tabular}            & cpu\_d\_req{[}`valid(0){]}      \\ \hline
    dBus\_cmd\_ready             & 1              & input              & \begin{tabular}[c]{@{}l@{}}Indicates that the SoC is ready\\  to receive a data request.\end{tabular}         & N/A                             \\ \hline
    dBus\_cmd\_payload\_wr       & 1              & output             & \begin{tabular}[c]{@{}l@{}}Indicates that the CPU wants\\  to write data to memory.\end{tabular}              & N/A                             \\ \hline
    dBus\_cmd\_payload\_uncached & 1              & output             & Indicates if data is on L1 cache                                                                              & Not used                        \\ \hline
    dBus\_cmd\_payload\_address  & 32             & output             & Used to address memory.                                                                                       & cpu\_d\_req{[}`address(0,32){]} \\ \hline
    dBus\_cmd\_payload\_data     & 32             & output             & Used to send data to memory.                                                                                  & cpu\_d\_req{[}`wdata(0){]}      \\ \hline
    dBus\_cmd\_payload\_mask     & 4              & output             & \begin{tabular}[c]{@{}l@{}}Indicates which bytes in a\\  word are accessed.\end{tabular}                      & N/A                             \\ \hline
    dBus\_cmd\_payload\_size     & 2              & output             & $log_2$(number of bytes in the burst)                                                                         & Not used                        \\ \hline
    dBus\_cmd\_payload\_last     & 1              & output             & \begin{tabular}[c]{@{}l@{}}Indicates when the last\\  byte is transferred.\end{tabular}                       & Not used                        \\ \hline
    dBus\_rsp\_valid             & 1              & input              & \begin{tabular}[c]{@{}l@{}}Indicates that the SoC is ready\\  to send a response.\end{tabular}                & cpu\_d\_resp{[}`valid(0){]}     \\ \hline
    dBus\_rsp\_payload\_last     & 1              & input              & \begin{tabular}[c]{@{}l@{}}Indicates when the last\\  byte is transferred.\end{tabular}                       & Not used                        \\ \hline
    dBus\_rsp\_payload\_data     & 32             & input              & Receive data from memory.                                                                                     & cpu\_d\_resp{[}`rdata(0){]}     \\ \hline
    dBus\_rsp\_payload\_error    & 1              & input              & Indicates existence of an error.                                                                              & Not used                        \\ \hline
    timerInterrupt               & 1              & input              & Indicate a Timer Interrupt.                                                                                   & timerInterrupt                  \\ \hline
    externalInterrupt            & 1              & input              & Indicate an External Interrupt.                                                                               & externalInterrupt               \\ \hline
    softwareInterrupt            & 1              & input              & Indicate a Software Interrupt.                                                                                & softwareInterrupt               \\ \hline
    externalInterruptS           & 1              & input              & \begin{tabular}[c]{@{}l@{}}Indicate an External Interrupt\\  at the Supervisor level.\end{tabular}            & Not used                        \\ \hline
    iBus\_cmd\_valid             & 1              & output             & \begin{tabular}[c]{@{}l@{}}Indicates that the CPU is ready\\  to make an instruction request.\end{tabular}    & cpu\_i\_req{[}`valid(0){]}      \\ \hline
    iBus\_cmd\_ready             & 1              & input              & \begin{tabular}[c]{@{}l@{}}Indicates that the SoC is ready\\  to receive an instruction request.\end{tabular} & N/A                             \\ \hline
    iBus\_cmd\_payload\_address  & 32             & output             & Used to address memory.                                                                                       & cpu\_i\_req{[}`address(0,32){]} \\ \hline
    iBus\_cmd\_payload\_size     & 2              & output             & $log_2$(number of bytes in the burst)                                                                         & Not used                        \\ \hline
    iBus\_rsp\_valid             & 1              & input              & \begin{tabular}[c]{@{}l@{}}Indicates that the SoC is ready\\  to send a response.\end{tabular}                & cpu\_i\_resp{[}`valid(0){]}     \\ \hline
    iBus\_rsp\_payload\_data     & 32             & input              & Receive an instruction from memory.                                                                           & cpu\_i\_resp{[}`rdata(0){]}     \\ \hline
    iBus\_rsp\_payload\_error    & 1              & input              & Indicates existence of an error.                                                                              & Not used                        \\ \hline
    clk                          & 1              & input              & System clock signal.                                                                                          & clk                             \\ \hline
    reset                        & 1              & input              & CPU reset signal.                                                                                             & cpu\_reset                      \\ \hline
    \end{tabular}%
  }
  \caption{\textit{VexRiscv} core inputs and outputs.}
  \label{tab:vexriscv_core_and_iob_soc}
\end{table}

After understanding the inputs and outputs of each module it is easy to see which wires should be connected. But after connecting all the wires there were three problems. The first was the \enquote{strb} signal needed by \textit{IOb-SoC} when writing data to memory which did not exist in the \textit{VexRiscv} signals. The \enquote{strb} signal could be obtained in two different ways. One way would be through the \enquote{dbus\_req\_size} signal, the two less significant bits of the \enquote{dbus\_req\_address} and the \enquote{dbus\_req\_wr} signal. The other way was through the \enquote{dBus\_cmd\_payload\_mask} signal and the \enquote{dBus\_cmd\_payload\_wr} signal. The \enquote{DBusSimplePlugin}, contrary to the \enquote{DBusCachedPlugin}, had no \enquote{dBus\_cmd\_payload\_mask} signal that is why the first method was created. Accordingly for the first method, the \enquote{mask} signal had to be generated by the hardware logic expressed in equation \ref{eq:mask_generated}. % Should I make a figure with a MUX and a shifter?

\begin{equation}
  \begin{cases}
    dbus\_req\_mask\_aux = dbus\_req\_size[1] ? {4'hF} : (dbus\_req\_size[0] ? {4'h3} : {4'h1}) \\
    dbus\_req\_mask = dbus\_req\_mask\_aux << dbus\_req\_address[1:0]
  \end{cases}
  \label{eq:mask_generated}
\end{equation}

Moreover, the \enquote{mask} signal indicated the active bytes when both read or write operations were occurring. On the other hand, the \enquote{strb} signal should only be active when a write operation is happening. Both methods logic expressions can be seen in equation \ref{eq:strb_vexriscv}. This implements a \acrshort{mux} where \enquote{dbus\_req\_wr} is the selection bit.

\begin{equation}
  \begin{split}
  strb& = dbus\_req\_wr ? dbus\_req\_mask : 4'h0 \\
      & = dbus\_req\_wr ? dBus\_cmd\_payload\_mask : 4'h0
  \end{split}
  \label{eq:strb_vexriscv}
\end{equation}

The second is that the \textit{IOb-SoC} internal bus did not contain all the signals that were needed by the \textit{VexRiscv} core. To successfully make the interface handshake with the \textit{VexRiscv} core an instruction and data request \enquote{ready} signal had to be generated. The \enquote{ready} signal indicated that the \acrshort{soc} was ready to receive and accept a request from the CPU. To solve this problem a register that saved the value of the \enquote{cmd\_valid}, called \enquote{valid\_reg}, was created. This register would be updated when either the \enquote{cmd\_valid} or the \enquote{rsp\_valid} signal were active. The \enquote{ready} signal should be high ('1') before accepting a request, and after it should be low ('0') while the response is not available. The initial approach to the values that the \enquote{cmd\_ready} signal should assume can be seen in the truth table \ref{tab:first_truth_table}. This truth table was obtained by analyzing the simulation signals wave. The \enquote{N/A} values in the table mean that those situations never occurred.

\begin{table}[!h]
  \centering
  \begin{tabular}{ccc|c}
  valid\_reg & cmd\_valid & rsp\_valid & cmd\_ready \\ \hline
  0          & 0          & 0          & 0          \\
  0          & 0          & 1          & N/A        \\
  0          & 1          & 0          & 1          \\
  0          & 1          & 1          & N/A        \\
  1          & 0          & 0          & 0          \\
  1          & 0          & 1          & 1          \\
  1          & 1          & 0          & 0          \\
  1          & 1          & 1          & 1         
  \end{tabular}
  \caption{First try at identifying the rules the cmd\_ready should follow.}
  \label{tab:first_truth_table}
\end{table}

The truth table can be transformed in a logic gates expression, which can be seen in equation \ref{eq:first_logic_eq}.

\begin{equation}
  (valid\_reg \cdot rsp\_valid) + (valid \cdot \overline{valid\_reg} \cdot \overline{rsp\_valid})
  \label{eq:first_logic_eq}
\end{equation}

But this approach had an issue. The logic expression depended on the \enquote{cmd\_valid} signal which was generated inside the \textit{VexRiscv} core. This could generate a bigger complication since the combinatorial circuit that generates the \enquote{cmd\_valid} is unknown and might generate an infinite hardware loop. From better analyzing the signal behavior it was noticed that when \enquote{valid\_reg}, \enquote{cmd\_valid} and \enquote{rsp\_valid} are low ('0') the value of \enquote{cmd\_ready} is irrelevant. It could be concluded since when the \enquote{valid\_reg}, \enquote{cmd\_valid} and \enquote{rsp\_valid} are low happens the \enquote{cmd\_ready} signal was not being used by the \textit{IOb-SoC}. The truth table can them be simplified to table \ref{tab:simple_truth_table}.

\begin{table}[!ht]
  \centering
  \begin{tabular}{cc|c}
  valid\_reg & rsp\_valid & req\_ready \\ \hline
  0          & 0          & 1          \\
  0          & 1          & N/A        \\
  1          & 0          & 0          \\
  1          & 1          & 1         
  \end{tabular}
  \caption{Simplified truth table.}
  \label{tab:simple_truth_table}
\end{table}

Which can be seen as a simple XOR logic gate. The equation \ref{eq:simple_logic_eq} show the hardware logic expression implement.

\begin{equation}
  (valid_reg \cdot rsp\_valid) + (\overline{valid_reg} \cdot \overline{rsp\_valid}) = valid_reg \odot rsp\_valid
  \label{eq:simple_logic_eq}
\end{equation}

The last problem was that after accepting an instruction or data request the values of the \enquote{address}, \enquote{data} and \enquote{mask} signals could change inside the \textit{VexRiscv} core. This changes would pass through \textit{iob\_VexRiscv} and reflect in the rest of \textit{IOb-SoC} hardware. Which caused the \textit{iob-cache} and peripherals to not function currently. This problem was solved by creating registers that saved the value of the \enquote{address}, \enquote{data} and \enquote{strb} signals when the request was accepted. The register values would then only change when the response was already received.

To finalize, the \acrshort{cpu} should be able to run firmware from both the internal and external memory. When the stage 0 bootloader is running the \acrfull{msb} of the instruction fetched address had to be forced to '0'. This would force the \acrshort{cpu} to fetch instructions from the boot hardware unit. When defined that the firmware had to run from the external memory (RUN\_EXTMEM=1) the first instruction fetched should be at address $0x80000000$. To achieve this requirement the \acrfull{msb}, when RUN\_EXTMEM=1 was defined as the negated value of the boot signal. When RUN\_EXTMEM=0 the \acrshort{msb} was forced to always be '0' since there is no need to access the external memory. On the data request bus, it should also be taken into account that the \acrshort{msb} had to be '0' when the \acrshort{cpu} wanted to access the peripherals.

\section{\textit{UART 16550}}
\label{section:uart}
The approach taken in this project was to adapt an existing open-source \acrfull{uart} core that is supported by the Linux kernel. The other option was to create a Linux driver compatible with \textit{iob-UART} and compile the kernel with it. The chosen approach seemed more adequate and a simpler solution.

Since the developed chip is supposed to be open-source the \acrshort{uart} core should also be open-source hardware. The core used was a \textit{\acrshort{uart}16550}~\cite{gorban2002uart} that has been made available by \textit{freecores} on \textit{github}. This \acrshort{uart} was written in Verilog, although it was an older version of Verilog it is still synthesisable by modern tools and easy to understand. The \textit{UART16550} core used implements a wishbone interface to interact with the \acrfull{soc}. Similarly to what was done with the CPU, I had to create a wrapper to adapt the core to the \textit{IOb-SoC}.

\subsection{\textit{UART 16550} Wrapper}
The wishbone interface is established in the top hardware module from the used \textit{UART16550} core. In table \ref{tab:uart16550_wishbone}, which can be obtained from the open-source \textit{UART16550} core documentation, it can be seen the wishbone interface signals. The wishbone specification determines that there needs to be a master and a slave. In this case when the \acrshort{cpu} sends a request signal for the \textit{UART16550} peripheral the master is the \acrshort{cpu} and the slave is the \textit{UART16550}.

\begin{table}[!ht]
  \centering
  \begin{tabular}{|l|l|l|l|}
  \hline
  \textbf{Port} & \textbf{Width} & \textbf{Direction} & \textbf{Description}          \\ \hline
  CLK           & 1              & Input              & Block's clock input           \\ \hline
  WB\_RST\_I    & 1              & Input              & Asynchronous Reset            \\ \hline
  WB\_ADDR\_I   & 5 or 3         & Input              & Used for register selection   \\ \hline
  WB\_SEL\_I    & 4              & Input              & Select signal                 \\ \hline
  WB\_DAT\_I    & 32 or 8        & Input              & Data input                    \\ \hline
  WB\_DAT\_O    & 32 or 8        & Output             & Data output                   \\ \hline
  WB\_WE\_I     & 1              & Input              & Write or read cycle selection \\ \hline
  WB\_STB\_I    & 1              & Input              & Specifies transfer cycle      \\ \hline
  WB\_CYC\_I    & 1              & Input              & A bus cycle is in progress    \\ \hline
  WB\_ACK\_O    & 1              & Output             & Acknowledge of a transfer     \\ \hline
  \end{tabular}
  \caption{WISHBONE interface signals.}
  \label{tab:uart16550_wishbone}
\end{table}

The interface between the \textit{IOb-SoC} and the \textit{UART16550} top hardware is established by the verilog module that acts as a \textit{UART16550} wrapper. The wrapper module is called \enquote{iob\_uart16550}. The \enquote{iob\_uart16550} hardware component has to generate the missing signal that are needed by the wishbone interface but do not exist in \textit{IOb-SoC}. In table \ref{tab:wishbone_iob_soc} the connection between the \textit{IOb-SoC} and the \textit{UART16550} wishbone interface can be analyzed. The missing signal are the \enquote{WB\_SEL\_I}, the \enquote{WB\_WE\_I} and the \enquote{WB\_STB\_I}. The select signal is similar to the \enquote{strb} signal but it should exist during write and read operations. This signal can be obtained through the two \acrfull{lsb} of the address signal. And since registers are addressed byte by byte only one bit at a time will be set to high on the select signal. The write signal is set to high whenever the \acrshort{cpu} wants to write to the \textit{UART16550} registers. This can be perceived through the \textit{IOb-SoC} \enquote{strb} signal. If any of the \enquote{strb} bits are enabled the \enquote{WB\_WE\_I} signal should be high ('1'). The transfer cycle should happen (i.e. \enquote{WB\_STB\_I} signal should be set to '1') when the \textit{UART16550} has accepted a request but still has not issued the response. Furthermore, the \textit{UART16550} has an interrupt output pin that is connected to the \acrshort{soc} \enquote{uartInterrupt}. The \acrshort{soc} \enquote{uartInterrupt} is then passed to the \acrshort{plic} unit.

\begin{table}[!ht]
  \centering
  \resizebox{\textwidth}{!}{%
  \begin{tabular}{|l|l|l|}
  \hline
  \textbf{UART16550 Wishbone} & \textbf{IOb-UART16550}                  & \textbf{IOb-SoC}                         \\ \hline
  CLK                         & clk                                     & clk                                      \\ \hline
  WB\_RST\_I                  & rst                                     & reset                                    \\ \hline
  WB\_ADDR\_I                 & address{[}`UART\_ADDR\_WIDTH-1:0{]}     & slaves\_req{[}`address(`UART16550,32){]} \\ \hline
  WB\_SEL\_I                  & 1\textless{}\textless{}address{[}1:0{]} & N/A                                      \\ \hline
  WB\_DAT\_I                  & wdata                                   & slaves\_req{[}`wdata(`UART16550){]}      \\ \hline
  WB\_DAT\_O                  & rdata                                   & slaves\_resp{[}`rdata(`UART16550){]}     \\ \hline
  WB\_WE\_I                   & | wstrb                                 & N/A                                      \\ \hline
  WB\_STB\_I                  & valid\&($\sim$ready)                    & N/A                                      \\ \hline
  WB\_CYC\_I                  & valid                                   & slaves\_req{[}`valid(`UART16550){]}      \\ \hline
  WB\_ACK\_O                  & ready                                   & slaves\_resp{[}`ready(`UART16550){]}     \\ \hline
  \end{tabular}%
  }
  \caption{\textit{UART16550} interface with \textit{IOb-SoC}.}
  \label{tab:wishbone_iob_soc}
\end{table}

Finally, the \enquote{iob\_uart16550} also has to pass the interface between the \textit{UART16550} core and the RS232 connector. That is why it implements the: txd output to transmit data through serial; the rxd input to receive data through serial; the cts input which indicates that the destination is ready to receive a transmission sent by the UART; the rts output which indicates that the UART is ready to receive a transmission from the sender. Those pins are connected to the development board RS232 connector.

\section{CLINT Unit}
\label{section:clint}
The \acrshort{clint} was the only hardware component that was developed from scratch. Even though, there already exist open-source \acrfull{clint} hardware modules. For example, the \acrshort{clint} used with the \textit{CVA6} core and developed by the \textit{PULP platform}. The problem with this \acrshort{clint} module is that it is written in system-Verilog and uses packages and definitions from the \textit{CVA6} core. The \acrshort{clint} core is a simple hardware component. Considering that it only needs a few registers and signals to work, as it was studied in section \ref{section:riscv}. The interface with \textit{IOb-SoC} would have to be developed independently of the \acrshort{clint} core used. The best solution was to fully create the \acrshort{clint} hardware unit.

The inputs and outputs of the \acrshort{clint} unit can be seen in table \ref{tab:clint_signals}. \enquote{N\_CORES} is the number of \acrshort{cpu} core that are used in the \acrshort{soc}. In the \acrfull{soc} developed there is only one core. But the \acrshort{clint} is built with a multi-core system in mind. Each core has its timer and software interrupt. As such, the \enquote{mtip} and \enquote{msip} registers width is the number of core, \enquote{N\_CORES}.

\begin{table}[!ht]
  \centering
  \resizebox{\textwidth}{!}{%
  \begin{tabular}{|l|l|l|l|l|}
  \hline
  \textbf{Port} & \textbf{Width} & \textbf{Direction} & \textbf{Description}                                                                                & \textbf{IOb-SoC Port}                \\ \hline
  clk           & 1              & input              & System clock                                                                                        & clk                                  \\ \hline
  rst           & 1              & input              & System reset                                                                                        & reset                                \\ \hline
  rt\_clk       & 1              & input              & Real-time clock                                                                                     & rtc                                  \\ \hline
  valid         & 1              & input              & \begin{tabular}[c]{@{}l@{}}Indicates that the CPU is ready\\   to make a data request.\end{tabular} & slaves\_req{[}`valid(`CLINT){]}      \\ \hline
  address       & 32             & input              & Register address.                                                                                   & slaves\_req{[}`address(`CLINT,16){]} \\ \hline
  wdata         & 32             & input              & Data to write to register.                                                                          & slaves\_req{[}`wdata(`CLINT){]}      \\ \hline
  wstrb         & 4              & input              & Used to generate a "write" signal.                                                                  & slaves\_req{[}`wstrb(`CLINT){]}      \\ \hline
  rdata         & 32             & output             & Data read from register.                                                                            & slaves\_resp{[}`rdata(`CLINT){]}     \\ \hline
  ready         & 1              & output             & \begin{tabular}[c]{@{}l@{}}Indicates that the CLINT is ready\\   to send a response.\end{tabular}   & slaves\_resp{[}`ready(`CLINT){]}     \\ \hline
  mtip          & N\_CORES       & output             & Raise a timer interrupt in a core.                                                                  & timerInterrupt                       \\ \hline
  msip          & N\_CORES       & output             & Raise a software interrupt in a core.                                                               & softwareInterrupt                    \\ \hline
  \end{tabular}%
  }
  \caption{CLINT interface with \textit{IOb-SoC}.}
  \label{tab:clint_signals}
\end{table}

The \enquote{rt\_clk} signal, although it is connected to \enquote{rtc} wire, is not available in \textit{IOb-SoC} since the development board does not have any \acrfull{rtc} crystal connected. The \acrshort{rtc} frequency is commonly 32.768 kHz, because it is a power of 2 ($2^15$) value. To get a precise 1-second period (1 Hz frequency) would only be needed a 15 stage binary counter. With a \acrshort{rtc} the \acrshort{clint} unit had to detect the rising edge of the \enquote{rt\_clk} signal. The rising edge was detected by taking samples of the \enquote{rt\_clk} signal at the system clock frequency. This is possible because the \acrshort{rtc} is slower than the system clock. If in the future the \acrshort{clint} unit developed is implemented in a system with a \acrshort{rtc} the hardware design can be easily adapted to it. Since the logic was already developed. % Talk about meta stability??

In the development boards used there is no \acrshort{rtc} so an alternative had to be found. The method implemented was simpler than the logic if there existed a \acrshort{rtc}. The system clock operates at 100 MHz so a counter was added to the design and each time that counter reached 999 the timer register would increment. Like this, a \acrshort{rtc} working at 100 kHz was simulated in the \acrshort{clint} hardware.

Concluding, the needed registers to develop a \acrshort{clint} unit in accordance with the RISC-V specifications were implemented. And the hardware logic needed to trigger the timer and software interrupts were described.

\section{PLIC Unit}
\label{section:plic}
The \acrshort{plic} is not essential to run a full feature \acrfull{os} on a \acrfull{soc}. Since the \acrshort{plic} is used to drive interrupts generated by other peripherals to the core, in this project the only peripheral connected to the \acrshort{plic} is the \textit{UART16550}. For the growth of the \acrshort{soc}, the \acrshort{plic} unit is very useful and a requirement to have. Some peripherals that might be added in the future also use the \acrshort{plic} hardware, for example, the \textit{ethernet} controller can be used to wake a core from low power mode.

Since the \acrshort{plic} hardware unit is more complex then the \acrshort{clint}, it was decided that an open-source \acrshort{plic} core would be adapted to the \textit{IOb-SoC}. There were three available cores. The \acrshort{plic} developed by \textit{lowRISC}~\cite{lowrisc_plic} is written in a variation of \textit{System Verilog}, consequently it is difficult to adapt and test. The \acrshort{plic} used with the \textit{CVA6} core, developed by the \textit{PULP platform}~\cite{pulp_plic}, started as a fork of an older version of the \textit{lowRISC}. This \acrshort{plic} unit is written in pure \textit{System Verilog}. I tried to adapt the \acrshort{plic} unit from \textit{PULP platform} but there were many incompatibilities with the \textit{IOb-SoC}. Finally, the \acrshort{plic} developed by \textit{RoaLogic}~\cite{roalogic_plic} was the hardware unit used as a starting point. The \textit{RoaLogic} \acrshort{plic} is also written in \textit{System Verilog} and implements an \textit{apb4} or \textit{ahb3lite} interface with the \acrshort{soc}. The biggest advantage of the \textit{RoaLogic} hardware is that the \acrshort{plic} relevant components for the \textit{IOb-SoC}, the \acrshort{plic} registers and core, are well separated from the modules that create the interface with the \acrshort{soc} and instantiate them. To integrate the a \acrshort{plic} unit on the \textit{IOb-SoC} I had to develop a \acrshort{plic} wrapper.

\subsection{PLIC wrapper}
The \acrshort{plic} wrapper had to create the interface with the \textit{IOb-SoC} internal buses. Furthermore, it needed to instantiate the \acrshort{plic} registers and core hardware modules.
....

