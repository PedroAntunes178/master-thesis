\chapter{Introduction}
\label{chapter:introduction}
In this chapter, the author will first talk about what motivates the development of this thesis project. Then he will refer to the project's objectives and results the project delivers. The author will also indicate which hardware and software components he had to develop to achieve the thesis goal. Furthermore lastly, the author will explain the overall composition of this thesis report.

\section{Motivation}
\label{section:motivation}
Having an Operating System (OS) on an embedded system can facilitate software development and add functionalities not available to bare metal applications. 

There are many available Real-Time Operating Systems (RTOS), for example freeRTOS~\cite{barry2008freertos}. These OSs provide the basic functionalities such as a scheduler, events, threads, semaphores and message-boxes. The Linux OS provides many more functionalities, but it is not in nature a real-time OS. That is, it does not guarantee that tasks can be executed within a deadline. The fundamental difference between an RTOS and Linux is memory management and protection. As the application base grows, one needs to add multitasking and network connectivity, and Linux already has these and many other functions built-in.

In Linux, if a user tries to run a buggy application, the kernel will kill it and maintain the other applications running. Linux manages the memory usage of applications behind what the user sees. The embedded system memory is managed by Linux, which leads to fewer memory problems. Besides that, with Linux, the user can run applications that take advantage of things like WebSockets. In general, using connections and communications protocols is more accessible when the Linux kernel is running behind. Linux limits the user applications access to the machine resources in terms of security, preventing misuse or damage. Implementing concurrent applications on bare-metal or even using an RTOS can be pretty challenging. Running multiple applications is just as easy as on personal computers with an OS like Linux.

In conclusion, what most motivates the development of a RISC-V SoC capable of running Linux is its advantages for future development.

\section{Objectives and Deliverables}
\label{section:objectives}
The goal of this dissertation work is to implement Linux on IOb-SoC. IOb-SoC is a modular SoC that allows developers to easily create and implement their hardware. IOb-SoC uses Verilog to describe its peripherals and connect them. Some peripherals that are in use at the current IOb-SoC are the iob-uart, the iob-cache, the iob-mem and iob-picorv32.

The hardware capable of running a UNIX OS, like Linux, will be developed. The hardware will not be developed from zero but will integrate multiple already developed open-source hardware. IOb-SoC will be used as the base hardware. Furthermore, a 32-bit RISC-V CPU capable of running Linux will be implemented into IOb-SoC.

An OS is a software, but more software besides the kernel needs to be compiled to have a functional Linux OS. Much software needs to run on the upgraded IOb-SoC platform. A Linux image should be flashed onto the board where IOb-SoC will be running at the end of this work. On power-on, the kernel should boot, and from there, the user should be able to run custom applications. 

The process of generating and deploying the Linux image to IOb-SoC should be thoroughly documented and automated so that, after this work, the generation of new images with different characteristics will be straightforward.

Finally, the system must be fully verified both on simulation and running on an FPGA board. For that, a fast Verilog simulator is needed, and the plan is t use the free of charge and open-source Verilator simulator and obtain high line and branch coverage of the whole hardware design.

\section{Author's Work}
\label{section:authors_work}
The author had to develop four hardware modules to develop a \acrfull{soc} capable of executing a Linux \acrshort{os}. Those hardware modules allowed the integration of a new \acrshort{cpu}, a new \acrshort{uart} and the hardware needed to support interrupts in the \textit{IOb-SoC}. Beside integrating new hardware in the \textit{IOb-SoC}, the author also made small changes to the \textit{IOb-SoC} core. The new \acrshort{cpu} is based on the \textit{SpinalHDL}~\cite{papon2017spinalhdl} \textit{VexRiscv}~\cite{vexriscv} platform. The \textit{VexRiscv} platform allowed the author to generate a \textit{VexRiscv} \acrshort{cpu} core that meets the requirements to execute an \acrlong{os}. Furthermore, the author still had to create a \acrshort{cpu} wrapper to adapt the \textit{VexRiscv} \acrshort{cpu} to the \textit{IOb-SoC}. Another hardware component the author had to develop was a wrapper for an \acrshort{uart} compatible with Linux. The author adapted the wishbone interface of a industry-standard \textit{UART16550} to the \textit{IOb-SoC}. A hardware component that generates timer and software-related interrupts for a \textit{RISC-V} system is called a \acrshort{clint}. The author fully developed the \acrshort{clint} hardware. Another hardware component manages interrupts generated by other peripherals in a \textit{RISC-V} system. This hardware component is the \acrshort{plic}, and the author adapted an already existing \acrshort{plic} module to the system by creating an interface that worked with \textit{IOb-SoC}.

During this thesis, the author also developed many software components. Those software components were either essential to run a Linux \acrshort{os} in \textit{IOb-SoC} or enhanced the \textit{IOb-SoC} platform. First, the author translated a program written in \textit{C} programming language, called \textit{Console}, which the \textit{IOb-SoC} platform uses to communicate through Serial with the board to \textit{Python}. Furthermore, the author added features to the \textit{Console} that made it capable of working with the simulator testbench and communicating with a Linux \acrshort{os} running in \textit{IOb-SoC}. Secondly, the author developed a new simulation testbench, based on the previous \textit{IOb-SoC} verification software, capable of communicating with the \textit{Console} program. Moreover, the author integrated the \textit{Verilator}~\cite{snyder2010verilator} simulation software in \textit{IOb-SoC} and created a \textit{Verilator} \textit{C++} testbench. Thirdly, the author created a simulation testbench for the \acrshort{clint} hardware and an interrupt routine firmware that took advantage of the \acrshort{clint}. The firmware created demonstrates how to use interrupts in \textit{IOb-SoC}. Finally, the author adapted, built and deployed the software needed to execute a Linux \acrshort{os} in the \acrshort{soc}. The author had to adapt the \textit{IOb-SoC} bootloader firmware. He created a device tree file describing the hardware components of the \acrshort{soc}. He compiled a Linux kernel version compatible with the \textit{VexRiscv} \acrshort{cpu}, and lastly developed a \acrshort{rootfs} adequate for a minimal Linux \acrshort{os}. While developing the hardware and software components, the author also developed Makefile scripts that helped with the integration on \textit{IOb-SoC} and automatise the building and deployment process.

Therefore, the author created a \acrshort{soc} capable of executing a Linux \acrshort{os} by changing the \textit{IOb-SoC} \acrshort{cpu} and adding three hardware peripherals. Additionally, the author developed software that improved the \textit{IOb-SoC} platform, complemented the hardware components created and allowed to execute a complete \acrlong{os} in the new \acrshort{soc}. The \acrshort{soc} developed might also be referred as \textit{IOb-SoC-Linux}.

\section{Thesis Outline}
\label{section:thesis_outline}
This thesis has five major chapters, which the author can divide into three segments. The state of the art is aborded in chapter \ref{chapter:must_have_concepts} and \ref{chapter:existing_embedded_technologies}. Chapter \ref{chapter:hardware_developed} and \ref{chapter:software_developed} discuss the components the author developed to achieve the thesis goal, and chapter \ref{chapter:project_results} shows the results of this thesis project. The thesis's first chapter (i.e. this chapter) is an introduction to the thesis, and the last chapter (\ref{chapter:conclusions}) is the conclusions the author makes after completing the project. The introduction and conclusion chapters do not count as major chapters.

In chapter \ref{chapter:must_have_concepts}, the author discusses the tools, concepts and standards the reader must understand to comprehend the following chapters and the decisions the author made while developing the thesis project. Chapter \ref{chapter:existing_embedded_technologies} presents the existing technologies capable of executing a full feature \acrlong{os} and discusses the possibility of integrating them in \textit{IOb-SoC}. The author described the hardware he had to develop in order to successfully create a \acrshort{soc} capable of executing a Linux \acrshort{os} in chapter \ref{chapter:hardware_developed}. Chapter \ref{chapter:software_developed} presents the software components the author had to develop. The software presented in chapter \ref{chapter:software_developed} is not only software needed to execute the Linux \acrshort{os} in the developed \acrshort{soc}, but also software that improves the \textit{IOb-SoC} platform and tests the hardware the author developed.

Finally, chapter \ref{chapter:project_results} shows the products of this expedition. In each step of this thesis development, the author achieved breakthroughs. For every breakthrough, the author obtained results that allowed analysing and discussing the hardware and software developed up until then.
